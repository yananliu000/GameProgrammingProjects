\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{class_action}{Action}} }{\pageref{class_action}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_action_database}{Action\+Database}} }{\pageref{class_action_database}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_action_definition}{Action\+Definition}} }{\pageref{class_action_definition}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_action_target_pair}{Action\+Target\+Pair}} }{\pageref{class_action_target_pair}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_ai_brain}{Ai\+Brain}} \\*Yanan Liu Agent wil pick the best action based on action scores. The original thougth is to utilize utility theory to make the ai be able to choose who to attack\+: based on player hp, player distance, player damage. But for the 2020 Spring, the project cancelled all the multiplayer features temporarily becaues of C\+O\+V\+ID 19, so the functionality hasn\textquotesingle{}t been developed }{\pageref{class_ai_brain}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_a_i_manager}{A\+I\+Manager}} }{\pageref{class_a_i_manager}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_ai_target}{Ai\+Target}} }{\pageref{class_ai_target}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_ammo}{Ammo}} }{\pageref{class_ammo}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_attack_action}{Attack\+Action}} }{\pageref{class_attack_action}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_context}{Context}} }{\pageref{class_context}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_controller_input}{Controller\+Input}} }{\pageref{class_controller_input}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_critter}{Critter}} \\*Culham Otton, Yanan Liu AI script controls the behavior of an individual scritter by using a simple state machine }{\pageref{class_critter}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_critter_test_player}{Critter\+Test\+Player}} }{\pageref{class_critter_test_player}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_decision_factor}{Decision\+Factor}} }{\pageref{class_decision_factor}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_distance_decision_factor}{Distance\+Decision\+Factor}} }{\pageref{class_distance_decision_factor}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_fade}{Fade}} }{\pageref{class_fade}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_hand_presence}{Hand\+Presence}} }{\pageref{class_hand_presence}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_landable_surface}{Landable\+Surface}} \\*Yanan Liu Designer can drag and drop the component on any gameobj to create an empty surface I would suggest to create an empty gameobject and it slight above or next to the tranform you want the surface to be }{\pageref{class_landable_surface}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_landing_controller}{Landing\+Controller}} \\*Yanan Liu The controller will assign a randomly landable postion (\mbox{\hyperlink{class_landing_controller_1_1_land_result}{Land\+Result}}) from its landing surfaces. Landing controllers should be owned by landing manager }{\pageref{class_landing_controller}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_landing_controller_manager}{Landing\+Controller\+Manager}} \\*The manager that owns all the landing controllers and assign to the requested agent a landable position from the closest controller }{\pageref{class_landing_controller_manager}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_landing_controller_1_1_land_result}{Landing\+Controller.\+Land\+Result}} }{\pageref{class_landing_controller_1_1_land_result}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_light_blink}{Light\+Blink}} }{\pageref{class_light_blink}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_my_game_manager}{My\+Game\+Manager}} }{\pageref{class_my_game_manager}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_my_math}{My\+Math}} }{\pageref{class_my_math}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_object_manager}{Object\+Manager}} }{\pageref{class_object_manager}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_projectile}{Projectile}} }{\pageref{class_projectile}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_shootable_object}{Shootable\+Object}} }{\pageref{class_shootable_object}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_spawner}{Spawner}} }{\pageref{class_spawner}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_spawner_pathing}{Spawner\+Pathing}} \\*Culham Otton Holds spawner and waypoint pathing by holding each waypoints next possiblities }{\pageref{class_spawner_pathing}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_swarm}{Swarm}} \\*Culham Otton + Yanan Liu Swarms of critters The idea was to keep the swarm a low cost as possible to allow more in the level at one time. L\+OD system aids in this }{\pageref{class_swarm}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_swarm_pathing}{Swarm\+Pathing}} \\*Culham Otton Controls what the swarm does when it hits a waypoint }{\pageref{class_swarm_pathing}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_target_health_decision_factor}{Target\+Health\+Decision\+Factor}} }{\pageref{class_target_health_decision_factor}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_timer}{Timer}} }{\pageref{class_timer}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_v_r_pistol}{V\+R\+Pistol}} }{\pageref{class_v_r_pistol}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_xorshift_r_n_g}{Xorshift\+R\+NG}} }{\pageref{class_xorshift_r_n_g}}{}
\end{DoxyCompactList}
